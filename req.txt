怎么做自动化测试？ --- 测试环境要和生产环境尽量隔离
1.单元测试：对代码中的每个函数、方法、类等进行测试，确保它们按照预期工作 -> 交给AI
  所有已提交的代码，都是可编译，可运行的，对于每个commit，都需要通过单测
  可以有自己的私人开发分支，这些分支可以不跑单测，可以不遵守上面的约定，但是最终需要合并到主分支，必须保证上面的原则
2.集成测试：将多个单元测试组合在一起，测试它们之间的交互和协作 
3.功能测试：模拟用户在系统中的操作，测试系统的整体功能和性能 
4.性能测试：测试系统的响应时间和吞吐量，确保系统在高负载下仍能正常工作 - 接口测试/整个系统测试，模拟用户的真实访问，保证不了是一样的
5.安全测试（功能测试的接口层，对外暴露的接口）：测试系统的安全性，确保没有安全漏洞 - 99%的厂子不会有安全测试，未知攻，焉知防 -> 让AI生成一些非法参数
6.回归测试：在代码修改后，重新运行之前的测试，确保修改没有引入新的问题 

自动化测试：
 Webhook可以理解为当你在本地完成代码工作后,Push提交到GitHub,GitHub检测到Push后,使用Webhook发送一条命令到你的VPS服务器上的Webhook Server
  Webhook Server接收到命令后,执行相应的操作,比如自动构建、自动部署、自动测试等
  要准备好编译脚本，部署脚本，测试脚本，这些脚本放在服务器上，Webhook Server会执行这些脚本
  编译脚本 go build xxx.go ，确保成功生成可执行文件
  部署脚本 docker build image -> docker push -> 修改yaml里的image -> kubectl apply -f xxx.yaml
  测试脚本 go test -v -coverprofile=coverage.out 哪些行执行了，哪些行没有执行，覆盖率报告，最终汇总所有测试用例，取得合集，看覆盖率
  UI测试：可以通过各种工具实现UI的自动化测试

Mock
函数A调用函数B
测试函数A，希望对于函数A相同的输入，输出是固定的，但是函数B的输出是随机的，这时候就需要Mock函数B，让函数B的输出是固定的
在写测试的时候，是不能修改被测试函数的

代码行覆盖率
if a:
  do something
else:
  do something else

if b:
  do something
else:
  do something else
测试用例1，执行了26、27行，31、32行
测试用例2，执行了28、29行，33、34行
代码行覆盖率100%
这种情况下，26、27行，33、34行这个路径(覆盖率)是没有覆盖到的
所以代码行覆盖率100%并没有代表没有问题，只是一个指标

代码质量考核指标
1.代码缩进深度，不得大于某个值，比如4
2.平均多少行代码出一个bug
3.代码覆盖率
4.从代码提交到上线的时间，工程质量的考核，
    发布窗口：
    比如周五不允许发布，因为周五发布没有人处理周末的问题
    有些业务场景周末压力比日常要高，比如赛事直播，所以周五可能暴露不出问题，在用户高峰期发现，周末才暴露问题，而且没人上班
    尤其不推荐周五晚上发布版本，用户体验很差
    发布熔断：
    出现故障以后，会暂停一段时间发布，从历史经验来看，出现故障一般都和新版本有关
    发布不允许一口气全量发布，必须要有灰度策略，分批发布，比如先发布10%，再发布20%，再发布30%，这样如果出现问题，影响面就小很多
    所以出现发布熔断后，发布进度会被卡住，导致代码迟迟不能上线，一些很敏感的业务，在业务低峰期发布，避免出问题的时候引发重大故障


外卖-评价-反馈
为什么传统评价系统有星级，因为数据库没法感知自然语言的满意程度，所以用星级来代替
星级本身无法体现具体满意还是不满意信息，所以我们需要想办法从自然语言的评价里获取有价值的信息
通过AI llm，可以得到用户具体的喜好，用来做产品运营，个性化的推荐，比如用户喜欢辣的，那么推荐一些辣的菜品，用户不喜欢辣的，那么推荐一些不辣的菜品
所以，sql通过自定义函数UDF，引入llm推理，在不改变传统编程模型的情况下，做到AI功能
https://docs.databricks.com/aws/en/large-language-models/ai-functions-example
mysql如何通过UDF实现类似功能
如商品描述信息，通过自定义UDF在sql里面提供更好的检索能力
通过embedding模型，提供图片检索能力，前提是，需要把每张图片的emb的结果都存入数据库，检索依赖向量查询，一般使用pgvector
电商场景，搜索相似女装
餐饮场景，图片搜菜

一般用pg数据库比较方便，但我项目前期用的是mysql，为了避免异构数据库，所以用mysql实现
mysql的UDF要求实现以下三个接口
第一个接口是 注册函数名_init 
第二个接口是 注册函数名 
第三个接口是 注册函数名_deinit
以下面的代码为例，注册函数名是max_two
所以需要实现max_two_init、max_two、max_two_deinit三个接口
max_two的返回值是91行的类型RETURNS INTEGER整数
     #include <mysql.h>
     extern "C" {
         my_bool max_two_init(UDF_INIT *initid, UDF_ARGS *args, char *message) {
             if (args->arg_count != 2) { 
                 strcpy(message, "max_two() requires two arguments");
                 return 1; 
             }
             return 0;
         }
         long long max_two(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error) {
             long long a = *((long long*)args->args[0]);
             long long b = *((long long*)args->args[1]);
             return (a > b) ? a : b;
         }
         void max_two_deinit(UDF_INIT *initid) {}
     }

gcc -Wall -fPIC -shared -I/usr/include/mysql -o lib_udf_max.so udf_max.c

CREATE FUNCTION max_two RETURNS INTEGER SONAME 'lib_udf_max.so';
创建函数max_two返回类型为integer整数，so_name为lib_udf_max.so


工程管理
git分支

1.主分支（如master或main）：代表稳定版本，用于发布。
    公开分支，可以随时上线，一般不允许往主分支上提交代码，只能往主分支上合并代码

2.开发分支（如develop）：日常开发的主要分支，集成新功能。
    公开分支，多个人可能往开发分支上合并代码，可能出现多个人修改了同一个文件，git合并导致冲突，需要有人修改代码解决冲突，开发分支完成后会往主干分支合并

3.功能分支（feature branches）：为开发特定功能而创建，完成后合并回开发分支。
    私人分支，没有其他人在上面提交代码，所以一般不会冲突，每当功能开发完毕，就会往开发分支上合并

4.预发布分支（release branches）：在发布前进行最后的测试和调整。
    主干分支虽然随时可上线，但不知主干分支上线了什么功能，或者不直观是x年x月的版本，所以会从主干分支定期分离出版本号出来，版本号不会提交新代码

5.修补分支（hotfix branches）：紧急修复线上问题时从主分支创建。
    可能从release分支分离出来，也可能从主干分支分离出来，修复完成后会往主干分支合并，同时往release分支合并，保证线上版本和预发布版本都是修复后的版本

git branch -a | grep release 看版本号
git branch -a | grep some_username 看某个人的分支
git branch -a |grep feature_name 看某个功能分支

golint，jslint
-Wall + 代码风格

非结构化数据
自然语言，藏了大量的商机